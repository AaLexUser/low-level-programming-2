\documentclass[12pt,onecolumn]{article}
\usepackage[utf8]{inputenc} % UTF8 input encoding
\usepackage[T2A]{fontenc}   % T2A font encoding for Cyrillic script
\usepackage[russian]{babel} % Russian language support
\usepackage{listings}
\usepackage{float}
\usepackage{mathtools}
\everymath{\displaystyle}
\usepackage{listings} 
\usepackage[usenames]{color}
\usepackage{geometry}
\usepackage{verbatim}
\newcommand{\nparagraph}[1]{\paragraph{#1}\mbox{}\\}
\geometry{
  a4paper,
  top=20mm, 
  right=25mm, 
  bottom=20mm, 
  left=20mm
}

\lstdefinestyle{C}{language=C, 
  basicstyle=\small\ttfamily,
  commentstyle=\color{cyan},
  stringstyle=\color{magenta}\ttfamily,
  keywordstyle=\color{blue},
  numbers=left,
  numberstyle=\scriptsize,
  numbersep=5pt,
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  showstringspaces=false,
  tabsize=4,
  inputencoding=utf8,
  extendedchars=true,
  literate={а}{{\selectfont\char224}}1
          {б}{{\selectfont\char225}}1
          {в}{{\selectfont\char226}}1
          {г}{{\selectfont\char227}}1
          {д}{{\selectfont\char228}}1
          {е}{{\selectfont\char229}}1
          {ё}{{\"e}}1
          {ж}{{\selectfont\char230}}1
          {з}{{\selectfont\char231}}1
          {и}{{\selectfont\char232}}1
          {й}{{\selectfont\char233}}1
          {к}{{\selectfont\char234}}1
          {л}{{\selectfont\char235}}1
          {м}{{\selectfont\char236}}1
          {н}{{\selectfont\char237}}1
          {о}{{\selectfont\char238}}1
          {п}{{\selectfont\char239}}1
          {р}{{\selectfont\char240}}1
          {с}{{\selectfont\char241}}1
          {т}{{\selectfont\char242}}1
          {у}{{\selectfont\char243}}1
          {ф}{{\selectfont\char244}}1
          {х}{{\selectfont\char245}}1
          {ц}{{\selectfont\char246}}1
          {ч}{{\selectfont\char247}}1
          {ш}{{\selectfont\char248}}1
          {щ}{{\selectfont\char249}}1
          {ъ}{{\selectfont\char250}}1
          {ы}{{\selectfont\char251}}1
          {ь}{{\selectfont\char252}}1
          {э}{{\selectfont\char253}}1
          {ю}{{\selectfont\char254}}1
          {я}{{\selectfont\char255}}1
          {А}{{\selectfont\char192}}1
          {Б}{{\selectfont\char193}}1
          {В}{{\selectfont\char194}}1
          {Г}{{\selectfont\char195}}1
          {Д}{{\selectfont\char196}}1
          {Е}{{\selectfont\char197}}1
          {Ё}{{\"E}}1
          {Ж}{{\selectfont\char198}}1
          {З}{{\selectfont\char199}}1
          {И}{{\selectfont\char200}}1
          {Й}{{\selectfont\char201}}1
          {К}{{\selectfont\char202}}1
          {Л}{{\selectfont\char203}}1
          {М}{{\selectfont\char204}}1
          {Н}{{\selectfont\char205}}1
          {О}{{\selectfont\char206}}1
          {П}{{\selectfont\char207}}1
          {Р}{{\selectfont\char208}}1
          {С}{{\selectfont\char209}}1
          {Т}{{\selectfont\char210}}1
          {У}{{\selectfont\char211}}1
          {Ф}{{\selectfont\char212}}1
          {Х}{{\selectfont\char213}}1
          {Ц}{{\selectfont\char214}}1
          {Ч}{{\selectfont\char215}}1
          {Ш}{{\selectfont\char216}}1
          {Щ}{{\selectfont\char217}}1
          {Ъ}{{\selectfont\char218}}1
          {Ы}{{\selectfont\char219}}1
          {Ь}{{\selectfont\char220}}1
          {Э}{{\selectfont\char221}}1
          {Ю}{{\selectfont\char222}}1
          {Я}{{\selectfont\char223}}1
}

\begin{document}
\setcounter{tocdepth}{4}
\begin{center}
    Федеральное государственное автономное образовательное учреждение высшего образования "Национальный Исследовательский Университет ИТМО"\\ 
    Мегафакультет Компьютерных Технологий и Управления\\
    Факультет Программной Инженерии и Компьютерной Техники \\
    \includegraphics[scale=0.3]{image/itmo.jpg} % нужно закинуть картинку логтипа в папку с отчетом
\end{center}
\vspace{1cm}


\begin{center}
    \textbf{Лабораторная №2}\\
    по дисциплине\\
    \textbf{'Низкоуровневое программирование'}
\end{center}

\vspace{2cm}

\begin{flushright}
  Выполнил Студент  группы P33102\\
  \textbf{Лапин Алексей Александрович}\\
  Преподаватель: \\
  \textbf{Кореньков Юрий Дмитриевич}\\
\end{flushright}

\vspace{6cm}
\begin{center}
    г. Санкт-Петербург\\
    2023г.
\end{center}

\newpage
\tableofcontents
\newpage

\section{Цель:}


Выданный вариант - 5 (AQL - ArangoDb Query Language)


Использовать средство синтаксического анализа по выбору, реализовать модуль для разбора некоторого
достаточного подмножества языка запросов по выбору в соответствии с вариантом формы данных. Должна
быть обеспечена возможность описания команд создания, выборки, модификации и удаления элементов
данных.
\section{Задачи:}
\begin{enumerate}
  \item {Изучить выбранное средство синтаксического анализа
   \begin{itemize}
    \item Средство должно поддерживать программный интерфейс совместимый с языком С
    \item Средство должно параметризоваться спецификацией, описывающий синтаксическую структуру
    разбираемого языка
    \item Средство может функционировать посредством кодогенерации и/или подключения
    необходимых для его работы дополнительных библиотек
    \item Средство может быть реализовано с нуля, в этом случае оно должно быть основано на
    обобщённом алгоритме, управляемом спецификацией
   \end{itemize}
  }
  \item {Изучить синтаксис языка запросов и записать спецификацию для средства синтаксического анализа
    \begin{enumerate}
      \item При необходимости добавления новых конструкций в язык, добавить нужные синтаксические
      конструкции в спецификацию (например, сравнения в GraphQL)
      \item {Язык запросов должен поддерживать возможность описания следующих конструкций:
      порождение нового элемента данных, выборка, обновление и удаление существующих
      элементов данных по условию
      \begin{itemize}
        \item {
          Условия
          \begin{itemize}
            \item На равенство и неравенство для чисел, строк и булевских значений
            \item На строгие и нестрогие сравнения для чисел
            \item Существование подстроки
          \end{itemize}
          \item Логическую комбинацию произвольного количества условий и булевских значений
          \item В качестве любого аргумента условий могут выступать литеральные значения
          (константы) или ссылки на значения, ассоциированные с элементами данных
          (поля, атрибуты, свойства)
          \item Разрешение отношений между элементами модели данных любых условий над
          сопрягаемыми элементами данных
          \item Поддержка арифметических операций и конкатенации строк не обязательна
          }
      \end{itemize}
      \item Разрешается разработать свой язык запросов с нуля, в этом случае необходимо показать
        отличие основных конструкций от остальных вариантов (за исключением типичных выражений
        типа инфиксных операторов сравнения)
      }
    \end{enumerate}
  }
  \item {
    Реализовать модуль, использующий средство синтаксического анализа для разбора языка запросов
    \begin{enumerate}
      \item Программный интерфейс модуля должен принимать строку с текстом запроса и возвращать
      структуру, описывающую дерево разбора запроса или сообщение о синтаксической ошибке
      \item Результат работы модуля должен содержать иерархическое представление условий и других
      выражений, логически представляющие собой иерархически организованные данные, даже
      если на уровне средства синтаксического анализа для их разбора было использовано
      линейное представление
    \end{enumerate}
  }
  \item Реализовать тестовую программу для демонстрации работоспособности созданного модуля,
  принимающую на стандартный ввод текст запроса и выводящую на стандартный вывод
  результирующее дерево разбора или сообщение об ошибке
  \item {
    Результаты тестирования представить в виде отчёта, в который включить:

    \begin{enumerate}
      \item В части 3 привести описание структур данных, представляющих результат разбора запроса
      \item В части 4 описать, какая дополнительная обработка потребовалась для результата разбора,
      представляемого средством синтаксического анализа, чтобы сформировать результат работы
      созданного модуля
      \item В части 5 привести примеры запросов для всех возможностей из п.2.b и результирующий вывод
      тестовой программы, оценить использование разработанным модулем оперативной памяти
    \end{enumerate}
  }
\end{enumerate}
\subsection{Выполнение}
Для создания лексического анализатора использовался \textbf{flex}.
Для создания синтаксического анализатора использовался \textbf{bison}.
Для перехода к новому запросу надо оставить пустую строку.
Для завершения программы надо вывести символ EOF (Ctrl+D в терминале).

\subsection{Структуры данных}
\begin{lstlisting}[style=C]
  /* Типы вершин AST */
  enum ntype
/* Абстрактное дерево */
struct ast {
    ntype_t nodetype;
    struct ast *l;
    struct ast *r;
};
/* Листья, соответствующих типов данных */
struct nint, struct nfloat, struct nstring

/* Узлы, соответствующие операциям */
/* Операция for */
struct for_ast {
    ntype_t nodetype;
    char* var; 
    char* tabname;  // имя таблицы
    struct ast* nonterm_list_head; // список действий
    struct ast* terminal; // завершающее действие
};

/* Операция filter */
struct filter_ast {
    ntype_t nodetype;
    struct ast* conditions_tree_root; // дерево условий
};

/* Операция insert */
struct insert_ast {
    ntype_t nodetype;
    char* tabname;
    struct ast* list; // список пар, ключ-значение
};

/* Операция update */
struct update_ast {
    ntype_t nodetype;
    char* tabname;
    struct ast* attr; // атрибут
    struct ast* list;
};

/* Операция remove */
struct remove_ast {
    ntype_t nodetype;
    char* tabname;
    struct ast* attr;
};

/* Операция return */
struct return_ast {
    ntype_t nodetype;
    struct ast* value;
};

/* Операция create */
struct create_ast {
    ntype_t nodetype;
    char* name;
    struct ast* difinitions;
};

/* Операция drop */
struct drop_ast {
    ntype_t nodetype;
    char* name;
};

/* Вспомогательные узлы для разных операций */
struct list_ast, struct filter_condition_ast,
struct filter_expr_ast, struct attr_name_ast,
struct merge_ast, struct pair_ast, struct condition_ast,
struct variable_ast, struct create_pair_ast
\end{lstlisting}


\section{Дополнительная обработка для результата разбора}
Разобранное выражение на основе правил грамматики преобразуется в вершину AST. 
Продолжая разбор мы создаем новые вершины дерева, связывая их с уже существующими.
После завершения разбора мы получаем дерево, которое можно обойти и вывести в stdout.
После создания новой вершины, мы обновляем указатель на корневую вершину, тем самым в любой момент времени мы можем получить корень дерева.
Если возникают ошибки, то они попадают в yyerror, который выводит сообщение об ошибке, а также строчку и колонку в stdout.
yyerror рекурсивно освобождает память, выделенную под дерево.
\subsection{Примеры запросов}
\subsubsection{Создание таблицы}
\begin{lstlisting}[style=C]
  > CREATE users WITH { name: string, lastname: string, student: bool, money: int, score: float}
  create: {
    tabname: users
    data: [
      definition: {
        name: name
        type: string
      }
      definition: {
        name: lastname
        type: string
      }
      definition: {
        name: student
        type: bool
      }
      definition: {
        name: money
        type: int
      }
      definition: {
        name: score
        type: float
      }
    ]
  }
\end{lstlisting}

\subsubsection{Удаление таблицы}
\begin{lstlisting}[style=C]
  > DROP users
  drop: {
    tabname: users
  }
\end{lstlisting}

\subsubsection{Добавление элемента в таблицу}
\begin{lstlisting}[style=C]
  > INSERT { name: "Alex", lastname: "Lapin", student: true, money: 100, score: 5.0 } INTO users      
  insert: {
    tabname: users
    data: [
      pair: {
        key: name
        value: {
          string: "Alex"
        }
      }
      pair: {
        key: lastname
        value: {
          string: "Lapin"
        }
      }
      pair: {
        key: student
        value: {
          bool: true
        }
      }
      pair: {
        key: money
        value: {
          int: 100
        }
      }
      pair: {
        key: score
        value: {
          float: 5.0000
        }
      }
    ]
  }
\end{lstlisting}

\subsubsection{Удаление элемента из таблицы}
\begin{lstlisting}[style=C]
    > FOR u IN users
    FILTER u.score < 2
    REMOVE u IN users
  for: {
    var: u
    tabname: users
    body: [
      filter: {
        conditions: {
          filter_expr: {
            cmp: <
            attr_name: {
              variable: u
              attrubute: score
            }
            int: 2
          }
        }
      }
    ]
    remove: {
      tabname: users
      attr_name: {
        variable: u
      }
    }
  }
\end{lstlisting}

\subsubsection{Обновление элемента в таблице}
\begin{lstlisting}[style=C]
  > FOR u IN users
  FILTER u.score < 2 AND u.name == "Alex"
  UPDATE u WITH { score: 5 } IN users
for: {
  var: u
  tabname: users
  body: [
    filter: {
      conditions: {
        logic: AND
        filter_expr: {
          cmp: <
          attr_name: {
            variable: u
            attrubute: score
          }
          int: 2
        }
        conditions: {
          filter_expr: {
            cmp: ==
            attr_name: {
              variable: u
              attrubute: name
            }
            string: "Alex"
          }
        }
      }
    }
  ]
  update: {
    tabname: users
    attr_name: {
      variable: u
    }
    data: [
      pair: {
        key: score
        value: {
          int: 5
        }
      }
    ]
  }
}
\end{lstlisting}

\subsubsection{Выборка элементов из таблицы с условиями}
\begin{lstlisting}[style=C]
  > FOR u IN users
  FILTER u.score > 4 || u.name == "Alex"
 FOR s IN students
  FILTER u.name == s.name && "Alex" IN u.name
  RETURN MERGE(u,s)
for: {
  var: u
  tabname: users
  body: [
    filter: {
      conditions: {
        logic: OR
        filter_expr: {
          cmp: >
          attr_name: {
            variable: u
            attrubute: score
          }
          int: 4
        }
        conditions: {
          filter_expr: {
            cmp: ==
            attr_name: {
              variable: u
              attrubute: name
            }
            string: "Alex"
          }
        }
      }
    }
    for: {
      var: s
      tabname: students
      body: [
        filter: {
          conditions: {
            logic: AND
            filter_expr: {
              cmp: ==
              attr_name: {
                variable: u
                attrubute: name
              }
              attr_name: {
                variable: s
                attrubute: name
              }
            }
            conditions: {
              filter_expr: {
                cmp: IN
                attr_name: {
                  variable: u
                  attrubute: name
                }
                string: "Alex"
              }
            }
          }
        }
      ]
    }
  ]
  return: {
    merge: {
      variable: u
      variable: s
    }
  }
}
\end{lstlisting}

\section{Запуск}
Для запуска программы надо выполнить команду make в папке с проектом.
После этого в папке с проектом появится исполняемый файл lab2.
Для запуска программы надо выполнить команду ./lab2.

\section{Выводы}
В ходе выполнения лабораторной работы было изучено средство синтаксического анализа \textbf{bison} и \textbf{flex}.
Был реализован модуль для разбора языка запросов по выбору в соответствии с вариантом формы данных.
Была обеспечена возможность описания команд создания, выборки, модификации и удаления элементов данных.
Был изучен базовый синтаксис языка AQL.
\end{document}